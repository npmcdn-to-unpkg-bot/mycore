%
%
\section{Das Query-Modell von MyCoRe}
%
%
MyCoRe bemüht sich, das Synatx-Modell der Suchabfragen an die existierenden Standards des W3C für {\bf XML Path Language (XPath) Version 1.0} (W3C Recommendation 16 November 1999) und {\bf XQuery 1.0: An XML Query Language} (W3C Working Draft 22 August 2003) anzugleichen. Dabei muss aber auch Rücksicht auf die Spezifik eines Systems zur Suche von Objekten und Metadaten genommen werden. Daher ist MyCoRe nicht  100\% XPath/XQuery konform, es wird sich jedoch bemüht, wo irgend möglich die Spezifikationen einzuhalten. Grund für diese Abweichungen sind die Praxisorientierung des MyCoRe-Systems. So sollen verschiedene Persistence-Systeme zum Einsatz kommen, welche sehr unterschiedliche Abfrage-Syntax, auch außerhalb der XML-Welt, implementieren.\\[2ex]
MyCoRe muss neben der eigentlichen Query noch erfahren, welche Datenmodell-Typen abzufragen sind. Auch dafür ist die Ursache in der Persistence-Unabhängigkeit von MyCoRe zu suchen. Es ist notwendig, die Typen auf die entsprechenden Stores zu mappen, damit die Suche erfolgreich ist. Als Beispiel soll hier der Content Manager 8 ItemType stehen. Möglich ist sowohl einzelne Typen, wie auch eine Liste davon anzugeben. Wichtig ist nur, dass die Elemente, nach denen gefragt wird, in allen Datenmodellen der Typen vorkommen (sonst könnte das Ergebnis der Suche falsch sein). Normalerweise wird die Typ-Liste in der Applikation festgelegt und an die entsprechenden Query-Schnittstellen im API übergeben, z. B. durch das SearchMaskServlet.\\[2ex]
%
\subsection{Operatoren}
Für MyCoRe werden die folgenden Operatoren innerhalb eines Test verwendet. Die Paare können wiederum mit AND bzw. OR verknüpft werden. Funktionen für Test werden unter MyCoRe nicht unterstützt. 
\begin{verbatim}
Single Query : Test { AND | OR Test ... }
Test :: Data-Object Operator Value
\end{verbatim}
\begin{itemize}
\item Operator = - ist für alle Values zulässig
\item Operator != - ist für alle Values zulässig
\item Operator < - ist nur für Datums- und Zahlenangaben zulässig
\item Operator <= - ist nur für Datums- und Zahlenangaben zulässig
\item Operator > - ist nur für Datums- und Zahlenangaben zulässig
\item Operator >= - ist nur für Datums- und Zahlenangaben zulässig
\item Operator like - versucht im Value den angegebenen String zu finden, als Wildcard ist * zulässig
\item Operator contains - arbeitet wie like, ist eine TextSearch-Engine verfügbar, so erfolgt die linguistische Suche darin.
\end{itemize}
Die Operatoren {\bf like} und {\bf contains} sind eine Ergänzung von MyCoRe um mit Textsuch-Mechanismen arbeiten zu können. Sie sind so nicht Bestandteil der W3C Spezifikationen, habe sich aber in der Praxis bewehrt.\\[2ex]
%
\subsection{Pfadangaben}
Die Pfadangaben für ein Data-Object können einfach oder geschachtelt sein, je nach dem, wie die einzelnen Text- bzw. Attributknoten des XML-Datenmodells logisch zusammengehören. \\
\begin{verbatim}
Text Knoten :: text()
Attribut Knoten :: @...
\end{verbatim}
Mögliche Konstrukte für einen Test sind also
\begin{verbatim}
@ID = "..."
metadata/rights/right/text() = "..."
metadata/masse/mass[text() = "..." and @type = "..."]
\end{verbatim}
%
\subsection{Abfragen von Objekt-Metadaten}
Unter Objekt-Metadaten sind alle Datenmodell-Typen zu verstehen, welche NICHT {\bf class} oder {\bf derivate} sind\footnote{siehe auch UsersGuide, Abschnitt 3.2.3}. Alle XML-Files der Objekt-Metadaten Typen haben als Master Tag {\bf /mycoreobject} und genau auf diesen Knoten als Return-Value ziehlen auch alle Queries unter MyCoRe. Der allgemeine Syntax ist also:
\begin{verbatim}
/mycoreobject[ ... ] { AND|OR /mycoreobject[ ... ] ... }
\end{verbatim}
Dies bedeutet, es können mehrere Abfragen hintereinander mit AND oder OR verknüpft werden. Das diese Anfragen alle auf den selben Datenraum laufen, dafür sorgt die oben beschiebene Festlegung des Typ-Elementes. \\[2ex]
%
\subsection{Resultat der Query}
Alle Antworten als Resultat der Anfrage werden in einem XML-Conatiner zusammengefasst und der Anwendung zurückgegeben. Der Aufbau des Containers ist dabei Persitence-unabhängig. Nachfolgend die XML-Struktur des Resulates eine Query:
\lstset{language=XML,fancyvrb=true,frame=btlr,breaklines,prebreak={\space\MyHookSign}}
\begin{lstlisting}[caption=XML-Syntax eines Metadaten-Objektes,label=lst:xml_syntax_mcrresults]
<mcr_results parsedByLayoutServlet="...">
<mcr_result host="..." id="..." rank="0" hasPred="..." hasSucc="...">
<mycoreobject 
  ...
</mycoreobject>
</mcr_result>
</mcr_results>
\end{lstlisting}
Das Attribut \mcridentifier{parsedByLayoutServlet} ist ein Flag, welches eine etwaige Vorverarbeitung des Ergebnisses durch das LayoutServlet anzeigt.\\[2ex]
Das Attribut \mcridentifier{host} beinhaltet entwerden '{\bf local}' oder den den Hostalias des Servers, von dem das Resultat stammt.\\[2ex]
Das Attribut \mcridentifier{id} ist die entsprechende MCRObjectID des Resultates.\\[2ex]
Das Attribut \mcridentifier{hasPred} ???\\[2ex]
Das Attribut \mcridentifier{hasSucc} ???\\[2ex]
%
\subsection{Abfragen von Derivaten}
Für die Derivate gelten die selben Regeln für die Queries. Bachten Sie jedoch, dass das Datenmodel fest vorgeschieben ist und das Matser Tag anders heisst. Das Resultat auf eine Anfrage wird auch in einen {\bf mcrresults}-Container verpackt.
\begin{verbatim}
/mycorederivate[ ... ] { AND|OR /mycorederivate[ ... ] ... }
\end{verbatim}
%
\subsection{Abfragen von Klassifikationen}
Klassifikationen werden in MyCoRe-Anwendungen erfahrungsgemäß am häufigsten abgefragt. Die Klassifikationen können nur nach einem sehr festen Schema abgefragt werden, wobei entwerder die gesamte Klassifikation oder nuer eine einzelne Kategorie zurückgegeben wird. Die XML-Struktur entspricht dabei immer der einer Klassifikation.
\begin{verbatim}
/mycoreclass[@classid = "..." { and @categid = "..." } ]
\end{verbatim}
%
\subsection{Klassenübersicht}
