%
%
\section{Das Query-Modell von MyCoRe}
%
%
MyCoRe bemüht sich, das Synatx-Modell der Suchabfragen an die existierenden Standards des W3C für {\bf XML Path Language (XPath) Version 1.0} (W3C Recommendation 16 November 1999) und {\bf XQuery 1.0: An XML Query Language} (W3C Working Draft 22 August 2003) anzugleichen. Dabei muss aber auch Rücksicht auf die Spezifik des MyCoRe-Systems zur Suche von Objekten und Metadaten genommen werden. Daher ist MyCoRe nicht  100\% XPath/XQuery konform, es wird sich jedoch bemüht, wo irgend möglich die Spezifikationen einzuhalten. Grund für diese Abweichungen sind die Praxisorientierung des MyCoRe-Systems, vor allem im Bereich digitaler Bibliotheken. So sollen verschiedene Persistence-Systeme zum Einsatz kommen, welche sehr unterschiedliche Abfrage-Syntax, auch außerhalb der XML-Welt, implementieren. Daher stellen der in diesem Abschnitt beschriebene Abfrage-Syntax nur einen recht keinen Teil der Möglichkeiten der W3C Spezifikationen dar. Er genügt aber in der Praxis, um recht komplexe Projekte zu realisieren.\\[2ex]
MyCoRe muss neben der eigentlichen Query noch erfahren, welche Datenmodell-Typen abzufragen sind. Auch dafür ist die Ursache in der Persistence-Unabhängigkeit von MyCoRe zu suchen. Es ist notwendig, die Typen auf die entsprechenden Stores zu mappen, damit die Suche erfolgreich ist. Als Beispiel soll hier der Content Manager 8 ItemType oder die Umsetzung unter eXist stehen. Möglich ist sowohl einzelne Typen, wie auch eine Liste davon anzugeben. Die Liste ist ein String mit folgendem Syntax:
\begin{verbatim}
String type_list = "type1[,...]"
\end{verbatim}
Wichtig ist nur, dass die Elemente, nach denen gefragt wird, in allen Datenmodellen der Typen vorkommen (sonst könnte das Ergebnis der Suche falsch sein). Normalerweise wird die Typ-Liste in der Applikation festgelegt und an die entsprechenden Query-Schnittstellen im API übergeben, z. B. durch das SearchMaskServlet.\\[2ex]
%
\subsection{Operatoren}
MyCoRe verwendet nur die folgenden Operatoren innerhalb eines Test. Dies begründet sich mit der Kompatibilität und Umsetzung gegenüber den einzelnen Persitence-Layern. Wenn weitere Operatoren benötigt werden, so müssen diese in ALLEN Persitence-Implementierungen eingebaut werden. \\[2ex]
Die einzelnen {\cc Test} können wiederum mit {\cc AND} bzw. {\cc OR} verknüpft werden. Funktionen für Test werden unter MyCoRe NICHT unterstützt. 
\begin{verbatim}
SingleQuery :: OutPath [ Tests ]
               Tests
Tests       :: Test { AND | OR Test ... }
Test        :: InPath Operator Value
\end{verbatim}
\begin{itemize}
\item Operator = - ist für alle Values zulässig
\item Operator != - ist für alle Values zulässig
\item Operator < - ist nur für Datums- und Zahlenangaben zulässig
\item Operator <= - ist nur für Datums- und Zahlenangaben zulässig
\item Operator > - ist nur für Datums- und Zahlenangaben zulässig
\item Operator >= - ist nur für Datums- und Zahlenangaben zulässig
\item Operator like - versucht im Value den angegebenen String zu finden, als Wildcard ist * zulässig
\item Operator contains - arbeitet wie like, ist eine TextSearch-Engine verfügbar, so erfolgt die linguistische Suche darin.
\end{itemize}
Die Operatoren {\bf like} und {\bf contains} sind eine Ergänzung von MyCoRe um mit Textsuch-Mechanismen arbeiten zu können. Sie sind so nicht Bestandteil der W3C Spezifikationen, habe sich aber in der Praxis bewehrt.\\[2ex]
%
\subsection{Pfadangaben}
Die Pfadangaben für eine SingleQuery können einfach oder einmal geschachtelt sein, je nach dem, wie die einzelnen Text- bzw. Attributknoten des XML-Datenmodells logisch zusammengehören. Alle hier aufgeführten Möglichkeiten sind relativ zu XML-Dokument-Wurzel.\\
\begin{verbatim}
OutPath :: a
           a/b
InPath  :: SpecialNodeFuncition
           @d
           text()
           c
           c/text()
           c/@d
           c/d/@e
           c/d/text()
SpecialNodeFuncition :: *
                        text()
                        doctext()
\end{verbatim}
Hier noch einige Hinweise:
\begin{itemize}
\item '*' als {\cc SpecialNodeFuncition} darf allein nur in einer {\cc SingleQuery} ohne {\cc OutPath} angegeben werden. Es erfolgt dann eine Suche über alle für TextSearch markierten Metadaten.
\item 'text()'  als {\cc SpecialNodeFuncition} darf allein nur in einer {\cc SingleQuery} ohne {\cc OutPath} angegeben werden. Es wird nach '*' überführt.
\item 'doctext()'  als {\cc SpecialNodeFuncition} ist für die Abfrage des TextSearch des Dokumentes vorgesehen.\footnote{Wird derzeit implementiert und ist bald verfügbar!}
\item MyCoRe kann bei Bedarf der Applikation um weitere {\cc SpecialNodeFuncition}'s ergänzt werden.
\end{itemize}
Nun einige gültige Beispiele :
\begin{verbatim}
text() contains "..."
* like "..."
@ID = "..."
metadata/rights/right = "..."
metadata/rights/right/text() = "..."
metadata/masse/mass[text() = "..." and @type = "..."]
doctext() contains "..."
\end{verbatim}
%
\subsection{Abfragen von Objekt-Metadaten}
Unter Objekt-Metadaten sind alle Datenmodell-Typen zu verstehen, welche NICHT {\bf class} oder {\bf derivate} sind\footnote{siehe auch UsersGuide, Abschnitt 3.2.3}. Alle XML-Files der Objekt-Metadaten Typen haben als Master-Tag {\bf /mycoreobject} und genau auf diesen Knoten als Return-Value zielen auch alle Queries unter MyCoRe. Der allgemeine Syntax ist also:
\begin{verbatim}
Query  :: OneQuery { AND|OR OneQuery { AND|OR ... } }
OneQuery :: /mycoreobject[ SpecialNodeFuncition ]
\end{verbatim}
Dies bedeutet, es können mehrere Abfragen hintereinander mit AND oder OR verknüpft werden. Für jedes Metadatum des Datenmodells ist eine {\cc OneQuery} zu formulieren. Das diese Anfragen alle auf den selben Datenraum laufen, dafür sorgt die oben beschiebene Festlegung des Typ-Elementes. Somit erhalten Sie ein korrektes Gesamtergebnis.\\[2ex]
%
\subsection{Resultat der Query}
Alle Antworten als Resultat der Anfrage werden in einem XML-Conatiner zusammengefasst und der Anwendung zurückgegeben. Der Aufbau des Containers ist dabei Persitence-unabhängig. Nachfolgend die XML-Struktur des Resulates eine Query:
\lstset{language=XML,fancyvrb=true,frame=btlr,breaklines,prebreak={\space\MyHookSign}}
\begin{lstlisting}[caption=XML-Syntax eines Metadaten-Objektes,label=lst:xml_syntax_mcrresults]
<mcr_results parsedByLayoutServlet="...">
<mcr_result host="..." id="..." rank="0" hasPred="..." hasSucc="...">
<mycoreobject 
  ...
</mycoreobject>
</mcr_result>
</mcr_results>
\end{lstlisting}
Das Attribut \mcridentifier{parsedByLayoutServlet} ist ein Flag, welches eine etwaige Vorverarbeitung des Ergebnisses durch das LayoutServlet anzeigt.\\[2ex]
Das Attribut \mcridentifier{host} beinhaltet entwerden '{\bf local}' oder den den Hostalias des Servers, von dem das Resultat stammt.\\[2ex]
Das Attribut \mcridentifier{id} ist die entsprechende MCRObjectID des Resultates.\\[2ex]
Das Attribut \mcridentifier{hasPred} ???\\[2ex]
Das Attribut \mcridentifier{hasSucc} ???\\[2ex]
%
\subsection{Abfragen von Derivaten}
Für die Derivate gelten die selben Regeln für die Queries. Bachten Sie jedoch, dass das Datenmodel fest vorgeschieben ist und das Master-Tag anders heisst. Das Resultat auf eine Anfrage wird auch in einen {\bf mcrresults}-Container verpackt.
\begin{verbatim}
Query  :: OneQuery { AND|OR OneQuery { AND|OR ... } }
OneQuery :: /mycorederivate[ SpecialNodeFuncition ]
\end{verbatim}
%
\subsection{Abfragen von Klassifikationen}
Klassifikationen werden in MyCoRe-Anwendungen erfahrungsgemäß am häufigsten abgefragt. Die Klassifikationen können nur nach einem sehr festen Schema abgefragt werden, wobei entwerder die gesamte Klassifikation oder nuer eine einzelne Kategorie zurückgegeben wird. Die XML-Struktur entspricht dabei immer der einer Klassifikation.
\begin{verbatim}
Query :: /mycoreclass[@ID = "..." { and @category like "..." } ]
\end{verbatim}
%
\subsection{Klassenübersicht}

